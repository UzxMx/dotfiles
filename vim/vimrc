" .vimrc
" Author: Mingxiang Xue <327110424@163.com>
" Source: https://github.com/UzxMx/dotfiles

" Preamble -------------------------------------------------------------------- {{{
if has('python3') " This will force python3 to be used
  silent echomsg 'Use python3'
endif

filetype plugin indent on
set nocompatible
" }}}

" Basic options --------------------------------------------------------------- {{{
set encoding=utf-8
set autoindent
set cursorline
set mouse=a
set splitbelow
set splitright
set number
" set relativenumber
" set textwidth=80
" set clipboard^=unnamed
" set clipboard^=unnamedplus
set backspace=indent,eol,start
set list lcs=tab:\|\ 

set confirm

set tags=./.tags;/,./tags;/ " This will look in the current directory for tags, and walk up the tree towards root until one is found

" vim-tags related settings
" TODO on mac osx, tags file content will be changed, results in tag not
" found.
let g:vim_tags_main_file = '.tags'
" For mac osx, we use ctags of HEAD version to support generating tags for
" objc project, because stable version don't support it.
if has('macunix')
  let g:vim_tags_ctags_binary = 'ctags --languages=objectivec --langmap=objectivec:.h.m'
endif

" Save when losing focus
au FocusLost * :wa
" }}}

" Tabs, spaces, wrapping {{{
set expandtab
set tabstop=2
set shiftwidth=2
set softtabstop=2
set wrap
" }}}

" Wildmenu completion {{{
set wildmode=longest,list
" }}}

" Backups {{{
" set undodir=~/.vim/tmp/undo//     " undo files
" set backupdir=~/.vim/tmp/backup// " backups
" set directory=~/.vim/tmp/swap//   " swap files
" set backup                        " enable backups
" }}}

" Leader {{{
let mapleader = ","
let maplocalleader = "\\"
" }}}

" Color scheme {{{
" syntax on
" let g:airline_theme = 'tender'
" colorscheme tender
" hi Visual guifg=NONE ctermfg=NONE guibg=#666666 ctermbg=245 gui=NONE cterm=NONE
" hi VisualNOS guifg=NONE ctermfg=NONE guibg=#666666 ctermbg=245 gui=NONE cterm=NONE

syntax enable
set background=dark
colorscheme solarized
" }}}

" Status line ----------------------------------------------------------------- {{{
" will hide status line
" set laststatus=0
" }}}

" Searching and movement ------------------------------------------------------ {{{
set ignorecase
set smartcase
set incsearch
" set showmatch
set hlsearch " Use :nohlsearch to clear highlight after searching
set gdefault

nnoremap <leader><space> :nohlsearch<cr>

" Search visual selected text
vnoremap // y/<c-r>"<cr>

" Keep search matches in the middle of the window.
nnoremap n nzzzv
nnoremap N Nzzzv
" }}}

" Directional Keys {{{
" Easy buffer navigation
noremap <C-h>  <C-w>h
noremap <C-j>  <C-w>j
noremap <C-k>  <C-w>k
noremap <C-l>  <C-w>l
noremap <leader>v <C-w>v
" }}}

" Folding --------------------------------------------------------------------- {{{
set foldlevelstart=99
set foldmethod=indent

" Space to toggle folds.
nnoremap <Space> za
vnoremap <Space> za
" }}}

" Various filetype-specific stuff --------------------------------------------- {{{
" Javascript {{{
augroup ft_javascript
    au!

    au FileType javascript setlocal foldmethod=marker
    au FileType javascript setlocal foldmarker={,}
    " au FileType javascript setl foldmethod=indent
augroup END
" }}}

" Markdown {{{
augroup ft_markdown
    au!

    au BufNewFile,BufRead *.m*down setlocal filetype=markdown

    " Use <localleader>1/2/3 to add headings.
    au Filetype markdown nnoremap <buffer> <localleader>1 yypVr=
    au Filetype markdown nnoremap <buffer> <localleader>2 yypVr-
    au Filetype markdown nnoremap <buffer> <localleader>3 I### <ESC>
augroup END
" }}}

" QuickFix {{{
augroup ft_quickfix
    au!
    au Filetype qf setlocal colorcolumn=0 nolist nocursorline wrap
augroup END
" }}}

" Ruby {{{
augroup ft_ruby
    au!
    " This will slow the vim
    " au Filetype ruby setlocal foldmethod=syntax

    " For ruby file, if not set re to 1, the ruby syntax will be slow
    au FileType ruby setlocal re=1 
augroup END
" }}}

" Vim {{{
augroup ft_vim
    au!

    au FileType vim setlocal foldmethod=marker
augroup END
" }}}

" Java {{{
augroup ft_java
  au!
  
  au FileType java setlocal tabstop=4 shiftwidth=4 softtabstop=4
augroup END
" }}}

" Groovy {{{
augroup ft_groovy
  au!
  
  au FileType groovy setlocal tabstop=4 shiftwidth=4 softtabstop=4
augroup END
" }}}

" Go {{{
augroup ft_go
  au!

  au Filetype go setlocal noexpandtab tabstop=4 shiftwidth=4 
augroup END
" }}}

" Objective-C {{{
augroup ft_objc
  au!

augroup END
" }}}
" }}}

" Quick editing --------------------------------------------------------------- {{{
nnoremap <leader>ev :split $MYVIMRC<cr>
nnoremap <leader>sv :source $MYVIMRC<cr>
" }}}

" NERDTree specific stuff --------------------------- {{{
let NERDTreeMinimalUI = 1
" au VimEnter * NERDTree
" nnoremap <silent> <C-\> :NERDTreeFind<CR>
nnoremap <silent> <C-n>n :NERDTree<CR>
nnoremap <silent> <C-n><C-n> :NERDTree<CR>
nnoremap <silent> <C-n>c :NERDTreeClose<CR>
nnoremap <silent> <C-n>f :NERDTreeFind<CR>
nnoremap <silent> <C-n><C-f> :NERDTreeFind<CR>
nnoremap <silent> <C-n>t :NERDTreeToggle<CR>
nnoremap <silent> <C-n><C-t> :NERDTreeToggle<CR>
nnoremap <silent> <C-n>r :NERDTreeCWD<CR>
nnoremap <silent> <C-n><C-r> :NERDTreeCWD<CR>
" }}}

" Text objects ---------------------------------------------------------------- {{{
" Next and Last {{{
" Motion for "next/last object". For example, "din(" would go to the next "()" pair
" and delete its contents.
onoremap an :<c-u>call <SID>NextTextObject('a', 'f')<cr>
xnoremap an :<c-u>call <SID>NextTextObject('a', 'f')<cr>
onoremap in :<c-u>call <SID>NextTextObject('i', 'f')<cr>
xnoremap in :<c-u>call <SID>NextTextObject('i', 'f')<cr>

onoremap al :<c-u>call <SID>NextTextObject('a', 'F')<cr>
xnoremap al :<c-u>call <SID>NextTextObject('a', 'F')<cr>
onoremap il :<c-u>call <SID>NextTextObject('i', 'F')<cr>
xnoremap il :<c-u>call <SID>NextTextObject('i', 'F')<cr>

function! s:NextTextObject(motion, dir)
  let c = nr2char(getchar())

  if c ==# "b"
      let c = "("
  elseif c ==# "B"
      let c = "{"
  elseif c ==# "d"
      let c = "["
  endif

  exe "normal! ".a:dir.c."v".a:motion.c
endfunction
" }}}
" }}}

" Tabularize {{{
nnoremap <Leader>a= :Tabularize /=<CR>
vnoremap <Leader>a= :Tabularize /=<CR>
nnoremap <Leader>a: :Tabularize /:\zs<CR>
vnoremap <Leader>a: :Tabularize /:\zs<CR>
" }}}

" Use Ag rather than Ack or grep {{{
let g:ackprg = 'ag --nogroup --nocolor --column'
" }}}

" tslime.vim {{{
command! TmuxResetVars execute "normal \<Plug>SetTmuxVars"
" }}}

" vim-rspec {{{
let g:rspec_command = 'call Send_to_Tmux("bundle exec rspec {spec}\n")'
map <Leader>t :call RunCurrentSpecFile()<CR>
map <Leader>s :call RunNearestSpec()<CR>
map <Leader>l :call RunLastSpec()<CR>
map <Leader>a :call RunAllSpecs()<CR>
" }}}

" Misc {{{
" Use the below config to avoid tabstop to be overridden in
" $VIMRUNTIME/ftpplugin/python.vim
let g:python_recommended_style = 0

inoremap <C-C> <Esc>
inoremap <C-D> <Del>

" Open a new tab using the current buffer
" map <C-\> :tab split<CR>:exec("tag ".expand("<cword>"))<CR>
" map <A-]> :vsp <CR>:exec("tag ".expand("<cword>"))<CR>

" If you want :UltiSnipsEdit to split your window.
let g:UltiSnipsEditSplit="vertical"
" When using UltiSnips with YCM, we should bind the following.
let g:UltiSnipsExpandTrigger="<c-j>"

let g:deoplete#enable_at_startup = 0

" switch the line between the current line and the below line
nnoremap - ddp
" switch the line between the current line and the above line
nnoremap _ ddkP

nnoremap <leader>" viw<esc>a"<esc>bi"<esc>lel
nnoremap <leader>' viw<esc>a'<esc>bi'<esc>lel
nnoremap <leader>\| viw<esc>a\|<esc>bi\|<esc>lel
nnoremap <leader>` viw<esc>a`<esc>bi`<esc>lel
" }}}

" Quickfix window {{{
nnoremap <leader>co :copen<cr>
nnoremap <leader>cc :cclose<cr>
" }}}

" Avoid mistakes {{{
command! WQ wq
command! Wq wq
command! W w
command! -bang Q q<bang>
command! -bang Qa qa<bang>
" }}}

" YouCompleteMe {{{
" use the following command to install:
" ./install.py --clang-completer --js-completer --java-completer
"
" TODO check YouCompleteme, warn if not installed
nnoremap <leader>g :YcmCompleter GoToDefinitionElseDeclaration<cr>
nnoremap <leader>f :YcmCompleter FixIt<cr>
nnoremap <leader>o :YcmCompleter OrganizeImports<cr>
" }}}

" vim-pbcopy: copy to the local machine's clipboard from the sshed remote machine {{{
let g:vim_pbcopy_remote_cmd = "pbcopy"
" }}}

" vim-closetag {{{
let g:closetag_filenames = "*.html,*.xml,*.xhtml,*.vue,*.erb,*.jsx"
" }}}

" Workaround {{{
" Workaround for caw.vim. If we don't call the below function, caw.vim can not
" detect the context_filetype.vim
au BufNewFile,BufRead * call context_filetype#get_filetype()
" }}}

" ctrlp.vim {{{
" Exclude ~/.rbenv subdirectories, for .rbenv contains .git directory
if getcwd() !~ '^'.$HOME.'/.rbenv/'
  " Ignore files in .gitignore
  let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files -co --exclude-standard']
else
  let g:ctrlp_working_path_mode = ''
endif
" }}}

" Format {{{
command! Reindent norm! gg=G

" vim-easy-align {{{
" Start interactive EasyAlign in visual mode (e.g. vipga)
xmap <leader>ga <Plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap <leader>ga <Plug>(EasyAlign)
" }}}

" }}}

" CtrlSF {{{
let g:ctrlsf_ignore_dir = ["node_modules", "tmp", "log"]

nmap     <C-F>f <Plug>CtrlSFPrompt
vmap     <C-F>f <Plug>CtrlSFVwordPath
vmap     <C-F>F <Plug>CtrlSFVwordExec
nmap     <C-F>n <Plug>CtrlSFCwordPath
nmap     <C-F>p <Plug>CtrlSFPwordPath
nnoremap <C-F>o :CtrlSFOpen<CR>
nnoremap <C-F>t :CtrlSFToggle<CR>
inoremap <C-F>t <Esc>:CtrlSFToggle<CR>
" }}}

" projectionist.vim {{{
let g:projectionist_heuristics = json_decode(join(readfile(expand('~/.projections.global.json'))))
" }}}

" vim-json {{{
" Disable concelling
let g:vim_json_syntax_conceal = 0
" }}}

" vim-rails {{{
let g:rails_projections = {
      \ "app/*.rb": {
      \   "alternate": "spec/{}_spec.rb"
      \ },
      \ "app/views/*.json.jbuilder": {
      \   "template": [
      \     "# frozen_string_literal: true"
      \   ]
      \ },
      \ "config/routes.rb": {
      \   "command": "routes"
      \ },
      \ "config/routes/*.rb": {
      \   "command": "routes"
      \ },
      \ "spec/spec_helper.rb": {
      \   "alternate": "spec/rails_helper.rb",
      \   "related": "spec/rails_helper.rb"
      \ },
      \ "spec/rails_helper.rb": {
      \   "command": "railshelper",
      \   "alternate": "spec/rails_helper.rb",
      \   "related": "spec/spec_helper.rb"
      \ },
      \ "spec/factories/*.rb": {
      \   "command": "factory",
      \   "alternate": "app/models/{singular}.rb"
      \ },
      \ "spec/controllers/*_spec.rb": {
      \   "template": [
      \     "# frozen_string_literal: true",
      \     "",
      \     "RSpec.describe {camelcase|capitalize|colons}, type: :controller do",
      \     "end"
      \   ]
      \ },
      \ "spec/models/*_spec.rb": {
      \   "template": [
      \     "# frozen_string_literal: true",
      \     "",
      \     "RSpec.describe {camelcase|capitalize|colons}, type: :model do",
      \     "end"
      \   ]
      \ }}
" }}}

" Utils {{{
" Run shell command from range and save the output to a scratch buffer.
" http://vim.wikia.com/wiki/Display_output_of_shell_commands_in_new_window
command! -range -complete=shellcmd -nargs=* ShellJSON <line1>,<line2>call s:RunShellCommand(<q-args>, 'json', 0)
command! -range -complete=shellcmd -nargs=* QShellJSON <line1>,<line2>call s:RunShellCommand(<q-args>, 'json', 1)
command! -range -complete=shellcmd -nargs=* Shell <line1>,<line2>call s:RunShellCommand(<q-args>, '', 0)
command! -range -complete=shellcmd -nargs=* QShell <line1>,<line2>call s:RunShellCommand(<q-args>, '', 1)
function! s:RunShellCommand(str, filetype, quiet) range
  if empty(a:str)
    let cmdline = join(map(range(a:firstline, a:lastline), "substitute(getline(v:val), '\\\\$', '', '')"), '')
  else
    let cmdline = a:str
  endif

  let expanded_cmdline = cmdline
  for part in split(cmdline, ' ')
     if part[0] =~ '\v[%#<]'
        let expanded_part = fnameescape(expand(part))
        let expanded_cmdline = substitute(expanded_cmdline, part, expanded_part, '')
     endif
  endfor

  if a:quiet == 1
    let expanded_cmdline = expanded_cmdline . ' 2>/dev/null'
  endif

  botright new
  setlocal buftype=nofile bufhidden=wipe nobuflisted noswapfile nowrap
  execute '$read !'. expanded_cmdline
  if a:filetype == 'json'
    setlocal ft=json
    execute ':Autoformat'
  endif
  1
endfunction

" Save previously closed window
augroup bufclosetrack
  au!
  autocmd WinLeave * let g:lastWinName = @%
augroup END
command -nargs=0 LastWindow call s:LastWindow()
function! s:LastWindow()
  exe "split " . g:lastWinName
endfunction

" Load buffer in the current window into a new window of a specified tab
command! -nargs=1 MoveToTab call s:OpenInTab(<q-args>, v:true)
command! -nargs=1 OpenInTab call s:OpenInTab(<q-args>, v:false)
function! s:OpenInTab(tab, close)
  let tabnr = tabpagenr()
  if tabnr == a:tab
    return
  endif

  let bufnr = bufnr('%')
  let winnr = winnr()

  execute 'normal! ' . a:tab . 'gt'
  vsplit
  execute 'buffer ' . bufnr

  if a:close == v:true
    tabprevious
    execute winnr . 'wincmd w' | wincmd c
    tabnext
  endif
endfunction
" }}}

" EditorConfig {{{
let g:EditorConfig_exclude_patterns = ['fugitive://.*', 'scp://.*']
" }}}

" emmet-vim {{{
let g:user_emmet_leader_key='<C-Q><C-Y>'
" }}}
