# vim: ft=zsh

# Make directory and change into it
mc() {
  mkdir -p "$1" && cd "$1"
}

todo() {
  vi ~/.dotfiles/doc/todo.md
}

enable_pry_rails() {
  unset DISABLE_PRY_RAILS
}

disable_pry_rails() {
  export DISABLE_PRY_RAILS=1
}

_fed() {
  local IFS target dir editor
  dir=$1
  shift
  IFS=$'\n'
  target=($(fd --type d --maxdepth 1 . $dir | fzf --query="$1" --select-1 --exit-0))
  if [ -n "$target" ]; then
    editor=${EDITOR:-vim}
    # Use brace to restore working directory
    (cd $target && $editor $target)
  fi
}

alias fevp="_fed ~/.vim/plugged"

# Select a directory from current directory and change to there.
fcd() {
  local dir
  dir=$(fd ${1:-.} --type d 2> /dev/null | fzf +m) && cd "$dir"
}

# Select a directory from configured directory lists and change to there.
c() {
  local dir
  local lines="\
$(find ~/.dotfiles -maxdepth 1 -type d -not -path "$HOME/.dotfiles/.git")
$HOME/tmp
$(if type zsh_utils_cd_path_fn &>/dev/null; then; zsh_utils_cd_path_fn; fi)\
"
  dir=$(echo "$lines" | fzf +m) && cd "$dir"
}

# This is a ZLE widget function that allows us to execute the command in the
# editing buffer by pressing CTRL-S.
_zle_capture_source_and_signal() {
  echo
  setopt shwordsplit
  local args=(${BUFFER})
  unsetopt shwordsplit
  capture_source_and_signal "${args[@]}"
  echo
  echo
  zle backward-kill-line
  zle reset-prompt
}
zle -N _zle_capture_source_and_signal
bindkey "^S" _zle_capture_source_and_signal

# Dynamically define a shell function in current context, which calls the
# wrapper for an executable. The wrapper can exit with specific codes to signal
# to the function, and data sent to FD 3 is captured by the function.
#
# Supported exit codes include:
#   100: use stdout as a command to execute and append that to shell history.
#   101: feed stdout into prompt line, allow user to edit.
#
# Note: only support zsh.
#
# @params:
#   $1: wrapper name, usually the executable name
#   $2: wrapper path
wrap_executable() {
  local name=$1
  local wrapper_path=$2

  eval "
    $name() {
      local result
      { result=\$($wrapper_path \"\$@\" 3>&1 >&4 4>&-) } 4>&1
      case \$? in
        100)
          print -s \"\${result:q}\"
          # Use 'command' to avoid dead loop.
          eval \"command \${result}\"
          ;;
        101)
          print -z \"\${result:q}\"
          ;;
      esac
    }
  "
}

wrap_executable ssh ~/.dotfiles/scripts/bin/ssh
wrap_executable rsync ~/.dotfiles/scripts/bin/rsync

# Copy with progress
cp_p() {
  rsync -WavP --human-readable --progress $1 $2
}

# Extract archive
x() {
  local dir
  dir="$(~/.dotfiles/bin/extract "$1")"
  if [ "$?" -eq "0" -a -n "$dir" ]; then
    cd "$dir"
  fi
}

a() {
  local script
  if [ $# -lt 2 ]; then
    script=$(~/.dotfiles/scripts/asdf_common_workflow.sh "$@")
    if [ $? -eq 0 -a -n "$script" ]; then
      eval "$script"
    fi
  else
    asdf "$@"
  fi
}
