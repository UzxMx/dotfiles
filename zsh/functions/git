# vim: ft=zsh

# No arguments: `git status .`
# With arguments: acts like `git`
g() {
  if [ $# -gt 0 ]; then
    git "$@"
  else
    git status .
  fi
}

gi() {
  curl -s "https://www.gitignore.io/api/$*"
}

# ftag - checkout git tag
ftag() {
  local tags tag
  tags=$(git tag) &&
  tag=$(echo "$tags" | fzf +m)
  if [ -n "$tag" ]; then
    git checkout -b $tag $tag
  fi
}

# fstash - easier way to deal with stashes
# type fstash to get a list of your stashes
# enter shows you the contents of the stash
# ctrl-d shows a diff of the stash against your current HEAD
# ctrl-b checks the stash out as a branch, for easier merging
fstash() {
  local out q k ref sha
  local IFS=$'\n'
  while out=$(
    git stash list --pretty="%gd %C(yellow)%h %>(14)%Cgreen%cr %C(blue)%gs" |
    fzf --ansi --no-sort --query="$q" --print-query \
        --expect=ctrl-d,ctrl-b,ctrl-o);
  do
    set -f
    lines=($(<<< "$out"))
    set +f
    if [[ ${#lines[@]} == 2 ]]; then
      q=
      k="${lines[1]}"
    else
      q="${lines[1]}"
      k="${lines[2]}"
    fi
    ref=$(echo ${lines[-1]} | awk '{print $1}' )
    sha=$(echo ${lines[-1]} | awk '{print $2}' )
    [[ -z "$sha" ]] && continue
    if [[ "$k" == 'ctrl-d' ]]; then
      git diff --color=always $sha | less -r
    elif [[ "$k" == 'ctrl-b' ]]; then
      git stash branch "stash-$sha" $sha
      break
    elif [[ "$k" == 'ctrl-o' ]]; then
      git stash pop $ref
      break
    else
      git stash show --color=always -p $sha | less -r
    fi
  done
}
